---
title:  "Binary Search, Parametric Search 이해하기"
date:   2021-07-03 11:36:51 +0900
categories: algorithm
---



알고리즘 문제를 풀다 보면 효율성 기준을 통과하지 못하는 경우가 종종 있습니다 🥲

이번 글에서는 이럴 때 떠올릴 수 있는 알고리즘 중 하나인 **이분탐색(Binary Search)**과 이와 유사한 **Parametric search**의 개념을 살펴보고, Parametric Search를 어떻게 풀 수 있을지 알아보도록 하겠습니다.

## Binary Search (이분탐색)

이분탐색은 쉽게 말하면 배열을 반씩 잘라가며 원하는 값을 탐색해나가는 알고리즘입니다. 중간에 위치한 값과 비교하고 바로 절반을 버리려면 배열이 정렬된 상태여야겠죠? 즉, 이진탐색은 **정렬된 배열에서 값을 찾아내는 검색 알고리즘**이라고 할 수 있겠습니다.

예를 들어 `[1,2,3,4,5,6,7,8,9]`라는 배열이 있을 때 9가 어디에 위치했는지 알고 싶다면 배열의 중간에 위치한 5와 찾고자 하는 값인 9를 비교해보고, 비교했을 때 5 < 9 이므로 반으로 가른 오른쪽 부분을 또 반으로 잘라서 탐색하면서 원하는 값 9를 찾을 때까지 반복하는 알고리즘입니다.

그냥 for문으로 원하는 값이 있는지 찾을 때는 시간복잡도가 O(n)이지만 이분탐색은 한 번 탐색할 때마다 탐색범위를 절반으로 줄여주기 때문에 매우 효율적입니다. **이분탐색의 시간복잡도는 O(logn)으로 알려져 있습니다.** 따라서 이분탐색을 사용할 수 있는 문제라면 이분탐색을 활용하는 것이 좋겠죠?

## Parametric Search (매개변수 탐색)

이분탐색 알고리즘을 이야기할 때 함께 나오는 탐색 방법인 Parametric Search는 이분탐색과 상당히 유사합니다.

사실 이분탐색을 응용한 알고리즘이라고 봐야 할 것 같습니다. 어떤 값의 최댓값, 최소값을 찾는 문제를 풀 때 쉽게 생각할 수 있는 방법은 최대를 찾을 때까지 이어진 값들을 계속 탐색해 나가는 것입니다. parametric search는 그렇게 하지 않고 **최대, 최소를 찾는 문제를 O, X로 바꿔서 접근하는 방식**입니다.

무슨 말이냐 하면, 구하고자 하는 값의 범위가 주어질 때, 그 중 하나의 값을 하나 잡고 조건을 만족하는지 묻는 것입니다. 그리고 문제의 조건을 만족시키는지 아닌지에 따라 범위를 점차 좁혀 나가면서 원하는 값을 얻을 때까지 반복하는 것입니다. 여기서 일정 값을 설정하고 범위를 줄이는 방식을 이분탐색의 기법을 활용하는 것입니다. 즉 범위가 있을 때 평균값 선택 -> 조건 만족하는지 여부에 따라 어느 반쪽으로 나아갈지 선택 -> 계속 반복해서 답을 찾는다. 이런 방식으로 답을 찾아가는 방식이 parametric search 방식입니다.

따라서 parametric search는 조건을 만족시킨 이후에도 최대, 최소를 찾기 위해 끝까지 탐색을 계속합니다.
Pararmetric Search의 시간복잡도는 binary search와 동일하게 **O(log n)**입니다.

### Presudo code

Parametric search 문제 몇 가지를 풀면서 수도코드를 간단히 작성해 보았습니다.

- 구하고자 하는 값(예를 들어 랜선의 최대 길이)이 가질 수 있는 최소값을 left, 최댓값을 right로 설정한다.

- while문 (left <= right 일때)

  - ```
    mid = (left + right)//2
    ```

     

    로 두고 mid로 연산하여 문제의 조건을 만족하는지 확인한다.

    - 조건을 만족하지 않는 경우 만족시키기 위해 두 가지(`left = mid +1` 또는 `right = mid -1`) 중 조건을 충족시키는 방향으로 하나를 업데이트한다.
    - 조건을 만족하는 경우에도 문제에서 주어진 최소, 최대 조건을 만족시키기 위해 업데이트를 한다.

- 만일 left > right가 되면, while 루프에서 빠져나와 결과값을 출력한다.

### 파이썬으로 Parametric Search 문제 풀어보기

백준에 있는 [나무자르기](https://www.acmicpc.net/problem/2805) 문제를 풀어봅시다.

> #### 문제
>
> 상근이는 나무 M미터가 필요하다. 근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. 정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기를 이용해서 나무를 구할것이다.
>
> 목재절단기는 다음과 같이 동작한다. 먼저, 상근이는 절단기에 높이 H를 지정해야 한다. 높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. 그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. 따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. 예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. 상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, 상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다) 절단기에 설정할 수 있는 높이는 양의 정수 또는 0이다.
>
> 상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. 이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.
>
> #### 입력
>
> 첫째 줄에 나무의 수 N과 상근이가 집으로 가져가려고 하는 나무의 길이 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)
>
> 둘째 줄에는 나무의 높이가 주어진다. 나무의 높이의 합은 항상 M보다 크거나 같기 때문에, 상근이는 집에 필요한 나무를 항상 가져갈 수 있다. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0이다.
>
> #### 출력
>
> 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.
>
> #### 예제 입력 1
>
> ```
> 4 7
> 20 15 10 17
> ```
>
> #### 예제 출력 1
>
> ```
> 15
> ```

방금 본 수도코드를 떠올리면서 문제를 풀어보겠습니다.

#### Step 1. 구하고자 하는 값이 가질 수 있는 최소값을 left, 최댓값을 right로 설정한다.

여기에서는 start, end로 설정했습니다.

```
start, end = 0, max(h_of_trees)   # 절단기 높이 0(바닥)이 최저, max(h_of_trees)가 최고(가장 높은 나무)
```

#### Step2. while문 (left <= right 일때)

```
while start <= end:
    mid = (start + end)//2
    sliced_len = 0   # 잘린 나무의 총 길이 저장
    for h in h_of_trees:
        if h - mid > 0:
            sliced_len += h-mid
    if sliced_len < m:  # 잘린 총 길이가 m보다 짧은 경우, 더 낮은 곳에서 잘라야.
        end = mid - 1
    else:  # 잘린 총 길이가 m과 같거나 긴 경우. 가져갈 수 있지만 가장 높은 절단기 상태를 얻기 위해 start 업데이트.
        start = mid + 1
```

#### Step3. 만일 left > right가 되면, while 루프에서 빠져나와 결과값을 출력한다.

이때 left와 right 중에서 원하는 상태를 얻고 최고/최저를 얻기 위해 업데이트하는 값이 **아닌** 다른 값을 출력해야 합니다.

나무자르기 문제를 보면 `start`는 가장 높은 절단기 위치를 얻기 위해 업데이트를 하는 변수이고, `end`는 조건이 만족되지 않았을 때 업데이트하는 변수이므로 `end`를 출력해야 합니다.

그도 그럴 것이, 처음에 조건을 만족하지 못할 때에는 end를 계속업데이트하고, end가 결정난 이후에는 start를 늘려가면서 최대 위치를 찾으므로, start가 하나 더 넘어갔을 때 while문이 종료되게 됩니다. 그러므로 조건을 만족시킨 채로 고정되어버린 `end`를 출력해야 합니다.

```
print(end)  # 원하는 상태를 얻고도 업데이트하는 start가 아닌 end를 출력한다. 
```

이러한 프로세스를 거치면 나무자르기 문제를 풀 수 있습니다. 전체코드는 다음과 같습니다. PyPy3으로만 통과가 되네요. 다른 분들의 풀이를 보니 parametric search의 알고리즘은 비슷한 것 같습니다.

#### 문제풀이 코드

```
# 나무 자르기
import sys

n, m = map(int, sys.stdin.readline().strip().split())
h_of_trees = list(map(int, sys.stdin.readline().strip().split()))
start, end = 0, max(h_of_trees)


while start <= end:
    mid = (start + end)//2
    sliced_len = 0
    for h in h_of_trees:
        if h - mid > 0:
            sliced_len += h-mid
    if sliced_len < m:  # 잘린 총 길이가 m보다 짧은 경우, 더 낮은 곳에서 잘라야.
        end = mid - 1
    else:  # 잘린 총 길이가 m과 같거나 그보다 긴 경우. 가져갈 수 있는 상태지만 가장 높은 상태를 얻기 위해 start  업데이트.
        start = mid + 1

print(end)  # 원하는 상태를 얻고도 업데이트하는 값이 아닌 end를 출력한다. 
```

시간효율성 면에서 사용할 수 있다면 아주 좋은 알고리즘이니 필요할 때 잘 써봐야겠습니다.

Binary Search와 Parametric Search를 이해하는데 도움이 되셨기를 바라면서 다음 글에서 뵙겠습니다.

이만 총총..

## References

- https://en.wikipedia.org/wiki/Parametric_search
- 박상길, 2020, 파이썬 알고리즘 인터뷰, 책만.
